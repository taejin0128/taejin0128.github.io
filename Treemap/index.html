<!DOCTYPE html><head>     <meta charset="utf-8">    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">     <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>    <link type="text/css" rel="stylesheet" href="css/stylesheet.css"/>        <title> Treemap - Drinks </title></head><body>    <div id="header">            <h2> Drink Sales on January 2010 </h2>    </div>    <ul id="navbar">        <li id="navlinkspace"> <a id="navlink" href="http://taejin0128.github.io/index.html"> HW1 </a> </li>        <li id="navlinkspace"> <a id="navlink" href="http://taejin0128.github.io/JsonEx/index.html"> HW2 </a> </li>        <li id="navlinkspace"> <a id="navlink" href="http://taejin0128.github.io/Bargraph/index.html"> HW3 </a> </li>        <li id="currentpage"> HW4 </li>        <li id="navlinkspace"> <a id="navlink" href="http://taejin0128.github.io/StackedBarGraph/index.html"> EXAM1 </a> </li>    </ul>    <div id="section">         <select>            <option value="size"> Size </option>            <option value="count"> Count </option>        </select>    </div>        <div id="body"> </div>    <div id="explanation">         <p> Below is a treemap which represents the drink sales on January 2010. </p>        <p> The treemap is divided to four big parts in America: South, East, Central, and West. </p>        <p> Each big part is divided by states which are included in the part. </p>        <p> Each state has the rectangles that represent the types of the drinks </p>         <p> Each state is assigned to different colors </p>        <p> Ths size of each rectangle in the state is sized by the drink sales. </p>        <p> Features: </p>        <p> 1) Zoom-in: When the rectangles or the titles are clicked, it represents their own treemap which shows the drink type. </p>        <p> 2) Option button: </p>           <p> - Size: Each rectangle is sized by the drink sales. </p>        <p> - Count: Each rectangle is equally sized. </p>     </div>    <div id="footer"> </div></body><script type="text/javascript">    var checkClick = 1;    var chartWidth = 550;    var chartHeight = 550;    var xscale = d3.scale.linear().range([0, chartWidth]);    var yscale = d3.scale.linear().range([0, chartHeight]);    var color = d3.scale.category10();    var headerHeight = 20;    var headerColor = "#555555";    var transitionDuration = 500;    var root;    var node;    var csvLink = "https://hivelab.org/static/coffee.csv";    var coffeeTree;      var treemap = d3.layout.treemap()        .size([chartWidth, chartHeight])        .sticky(true)        .value(function(d) { return d.size; });    var chart = d3.select("#body")        .append("svg:svg")        .attr("width", chartWidth)        .attr("height", chartHeight)        .append("svg:g");    d3.csv(csvLink, function(data) {        coffeeTree = d3.nest()            .key(function(d) { if (d.date === "1/1/2010" ) { return "Drink Sales on January 2010"; } })             .key(function(d) {return d.region; })                                .key(function(d) {return d.state; })            .entries(data);        var temp = coffeeTree[0];        var root = reSortRoot(temp, "sales", "type");        var nodes = treemap.nodes(root);        node = root;        var children = nodes.filter(function(d) { return !d.children; });        var parents = nodes.filter(function(d) { return d.children; });        // Parent cells        var parentCells = chart.selectAll("g.cell.parent")            .data(parents, function(d) { return d.name; });                 var parentEnterTransition = parentCells.enter()            .append("g")            .attr("class", "cell parent")            .on("click", function(d) {                 checkClick = 0;                 zoom(d);             });                        parentEnterTransition.append("rect")            .attr("width", function(d) { return Math.max(0.01, d.dx); })            .attr("height", headerHeight)            .style("fill", headerColor);                       parentEnterTransition.append("foreignObject").attr("class", "foreignObject")            .append("xhtml:body").attr("class", "labelbody")            .append("div").attr("class", "label");        // Children cells        var childrenCells = chart.selectAll("g.cell.child")            .data(children, function(d) { return d.state + d.name; });                 // Enter transition        var childEnterTransition = childrenCells.enter()            .append("g")            .attr("class", "cell child")            .on("click", function(d) {                          checkClick = 0;                 zoom(node === d.parent ? root : d.parent);             });        childEnterTransition.append("rect")            .classed("background", true)            .style("fill", function(d) { return color(d.parent.name); });        childEnterTransition.append('foreignObject')            .attr("class", "foreignObject")            .attr("width", function(d) { return Math.max(0.01, d.dx); })            .attr("height", function(d) { return Math.max(0.01, d.dy); })            .append("xhtml:body")            .attr("class", "labelbody")            .append("div")            .attr("class", "label")               .text(function(d) { return d.name; });         if (checkClick) {            checkClick = 0;            childEnterTransition.selectAll(".foreignObject").style("display", "none");        } else {            checkClick = 1;            childEnterTransition.selectAll(".foreignObject .labelbody .label").style("display", "none");        }        d3.select("select").on("change", function() {        //d3.select("#section").on("change", function() {                treemap.value(this.value == "size" ? function(d) { return d.size; } : function() { return 1; } )                   .nodes(root);                        zoom(node);        });        zoom(node);    });  function reSortRoot(root, value_key, value_name) {    for (var key in root) {      if (key == "key") {        root.name = root.key;        delete root.key;      }      if (key == "values") {        root.children = [];        for (item in root.values) {            root.children.push(reSortRoot(root.values[item], value_key, value_name ));        }        delete root.values;      }      if (key == value_key) {        root.size = parseFloat(root[value_key]);        root.name = root[value_name];        delete root[value_key];        delete root[value_name];      }    }    return root;  }    function zoom(d) {                this.treemap            .padding([headerHeight/(chartHeight/d.dy), 0, 0, 0])            .nodes(d);        var kx = chartWidth  / d.dx;        var ky = chartHeight / d.dy;        var level = d;        xscale.domain([d.x, d.x + d.dx]);        yscale.domain([d.y, d.y + d.dy]);        if (node != level) {            if (!checkClick) {                checkClick = 1;                chart.selectAll(".cell.child .foreignObject")                    .style("display", "none");            } else {                checkClick = 0;                chart.selectAll(".cell.child .foreignObject .labelbody .label")                    .style("display", "none");            }        }        var zoomTransition = chart.selectAll("g.cell").transition().duration(transitionDuration)            .attr("transform", function(d) { return "translate(" + xscale(d.x) + "," + yscale(d.y) + ")"; })            .each("end", function(d, i) {                if (!i && (level !== self.root)) {                    chart.selectAll(".cell.child")                        .filter(function(d) { return d.parent === self.node; })                         .select(".foreignObject .labelbody .label")                        .style("color", "white");                     if (checkClick) {                        chart.selectAll(".cell.child")                            .filter(function(d) { return d.parent === self.node; })                            .select(".foreignObject")                            .style("display", "");                        checkClick = 0;                    } else {                        chart.selectAll(".cell.child")                            .filter(function(d) { return d.parent === self.node; })                            .select(".foreignObject .labelbody .label")                            .style("display", "");                        checkClick = 1;                     }                }            });        zoomTransition.select(".foreignObject")            .attr("width", function(d) { return Math.max(0.01, kx * d.dx); })            .attr("height", function(d) { return d.children ? headerHeight: Math.max(0.01, ky * d.dy); })            .select(".labelbody .label")            .text(function(d) { return d.name; });        zoomTransition.select("rect")            .attr("width", function(d) { return Math.max(0.01, kx * d.dx); })            .attr("height", function(d) { return d.children ? headerHeight : Math.max(0.01, ky * d.dy); })            .style("fill", function(d) { return d.children ? headerColor : color(d.parent.name); });        node = d;    }</script></html>